# Chimaera
KG+NLP+LISP+Prolog+ANN+Hook=Junk
# 模块1. Py2Neo & Neo4J：
用知识图谱（KG）存储有限状态机（FSM）

用节点存储状态标志（SS），用关系存储状态转移标志（TS）

在此基础上利用一系列工具操作、解析节点-关系信息
# 模块2. NLTK
用于使用自然语言命令行进行交互，创建和删除SS、TS，仅支持英文

对简化的自然语言进行词性标注，提取文本中由SS-TS-SS构成的三元组（Triplet）

关系动词的时态会在这个阶段强制转换为第三人称单数，对应KG接口的TS参数字符串也应为第三人称单数的动词

人称代词的时态会强制转为主格，对应CYPHER中变量的代词代换规则
# 模块3. Hy：
FSM在状态不变时，特定State下Chimaera对外暴露接口的底层实现模块

从KG中的LISP_VAL和LISP_FUNC节点生成用于表示函数调用树的广义表

再将广义表格式化为字符串后调用Hy模块解析执行

利用Hy的宏（defmacro）动态更新SI实现元编程
# 模块4. Pengines & SWI-Prolog：
连接SWI-Prolog，利用基于Prolog实现的推理引擎对SS-TS进行推理（TS查找与填补）

由于Prolog对大小写敏感，因此所有TS从KG中获取后都需要进行小写化，而SS都只采用数字id而非名称字符串

反过来这也要求KG中出现的TS也必须均为可用固定程序从小写字符串转换过来的形式
# 模块5. TensorFlow & Numpy：
利用ANN进行SS分类和TS预测（非一阶逻辑可推导的情形，不适用于Prolog推理引擎）

从KG中读取含有层对象构造参数的节点并根据这些节点及其之间的关联信息生成对应的Keras模型

将Triplet转化为有向图的邻接矩阵作为ANN的输入和标签，对模型进行训练，获取权重
# 模块6. Ctypes & Win32API
作为TI的底层实现用于与其它内存空间中的进程交互，获取函数指针或是数据，以嵌入到SI当中

1.调用kernel32.dll，使用其开放的API读写进程中指定内存数据：

查找进程->确定进程主模块->

根据主模块信息确定内存地址区间->

内存区间内搜索与匹配->改写&监听变量

2.对指定函数进行代理（Hook），读写入参和返回值：

查找进程->确定需要代理的模块->

根据模块路径找到dll->用dumpbin获取函数名->

根据函数名找到函数地址->查找进程内存中指向此地址的数据->

替换为含有原函数调用语句的代理函数
# 节点类型：
### 状态机-状态节点:
用于表示状态机的各个不同状态

互相之间由TRANSITION关系连接

各个状态所允许的接口功能的出口函数的函数节点由FUNC_OF关系指向对应的状态节点
### 状态机-函数节点：
HY脚本当中函数调用树所构成的节点

底层的函数以PARAM_OF关系指向带有该函数返回值作为入参的其它函数

也有常量参数会以PARAM_OF关系指向调用该数值的函数
### 状态机-常量节点：
HY脚本当中函数调用树的常量部分
### 神经网络-层对象节点：
用于表示神经网络模型当中某一抽象层，记录有该层的初始化参数

通过FLOW_TO指向该层数据流流向的其它层

输入节点会被所有元数据节点所指向，用于定位模型的输入

输出节点会指向所有的元数据节点，用于定位模型的输出
### 神经网络-元数据节点
记录神经网络的编译、训练及其它操作的节点

所有元数据节点均指向其对应抽象模型个例的输入节点

所有元数据节点均被其对应抽象模型个例的输出节点所指向
### 语言与推理-语义网络节点
从自然语言的语法树中提取实体生成的简单语义网络

谓词关系以PRECEDES表示，从主语节点指向宾语节点

谓词的实际内容记录在PRECEDES关系的word属性当中
# 名词解释：
### KG（Knowledge Graph）：
包含有状态机的状态标志（SS）和状态转移标志（TS）的图数据库
### State：
图数据库中的一个节点，对应状态机中的一个状态标志，含有一个数据库唯一标识id、分类标签及SS
### Transition：
图数据库中的一个关系，对应状态机中的一个状态转移标志，含有其起始SS的id、终点SS的id及TS
### SS（State Symbols）：
为了方便在其它工具中处理SS，用一个图中唯一的名称字符串来表示State
### TS（Transition Symbols)：
为了方便在其它工具中处理TS，用一个仅含大写英文+下划线构成的第三人称单数动词短语字符串来表示Transition
### SI（State Interfaces）：
状态不发生变化时，在某一特定状态下，Chimaera对外开放的接口所对应Hy脚本当中的实现

函数的嵌套逻辑是用广义表从KG的特殊子图中生成的
### TI（Transition Injectors）：
状态发生变化时，介于两个状态之间的状态转移事件所包含的MetaHook任务

用于将上一状态SI运行得到的记录数据反馈给有需要的外部进程，或是将SI过程代理为外部进程的函数

以及从内存获取下一状态时SI底层运行必要的常量数据和函数引用地址